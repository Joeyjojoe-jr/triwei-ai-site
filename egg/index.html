<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <base href="./">
  <title>triwei egg</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0b0d12 url('logo.png') no-repeat center center / contain; color:#e6eef7; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    #egg-container { position: fixed; inset: 0; display:grid; place-items:center; background: rgba(5,7,12,0.98); }
    #game-wrap { position:relative; width: min(100vw, 1024px); height: min(100vh, 576px); aspect-ratio: 16/9; box-shadow: 0 10px 40px rgba(0,0,0,.6); border-radius: 16px; overflow: hidden; border:1px solid rgba(255,255,255,.1); }
    canvas { display:block; width:100%; height:100%; background: #10131a; }
    #hud { position:absolute; left:0; right:0; top:0; padding:8px 12px; display:flex; gap:12px; align-items:center; font-weight:600; text-shadow: 0 2px 10px rgba(0,0,0,.7); }
    .pill { background: rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); padding:6px 10px; border-radius:999px; }
    #shop { position:absolute; inset:auto 0 0 0; background: rgba(8,10,16,.92); border-top: 1px solid rgba(255,255,255,.12); padding:12px; display:none; }
    #shop h3 { margin:0 0 8px 0; font-size:14px; font-weight:700; opacity:.9; }
    #shop .grid { display:grid; grid-template-columns: repeat(5, minmax(0, 1fr)); gap:8px; }
    .card { background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:8px; font-size:12px; }
    .card button { width:100%; margin-top:6px; background:rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.18); color:#e6eef7; border-radius:8px; padding:6px; cursor:pointer; }
    .muted { opacity:.75 }
  </style>
</head>
<body>
  <div id="egg-container" aria-hidden="false">
    <div id="game-wrap">
      <canvas id="game" width="1024" height="576"></canvas>
      <div id="hud">
        <span class="pill" id="hud-coins">⟡ 0</span>
        <span class="pill" id="hud-dist">0 m</span>
        <span class="pill">WASD/Arrows jump=Space dash=Shift shop=S</span>
        <span class="pill muted">theme:<span id="hud-theme">auto</span></span>
      </div>
      <div id="shop">
        <h3>Upgrades</h3>
        <div class="grid" id="shop-grid"></div>
      </div>
    </div>
  </div>

<script>
(function(){
  const THEMES = [
    {id:1, slug:"theme-1-neon"},
    {id:2, slug:"theme-2-forest"},
    {id:3, slug:"theme-3-desert"},
    {id:4, slug:"theme-4-ocean"},
  ];
  const STORAGE_KEY = "triwei_egg_save_v1";

  function isoWeek(date){
    const tmp = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    const dayNr = (tmp.getUTCDay() + 6) % 7;
    tmp.setUTCDate(tmp.getUTCDate() - dayNr + 3);
    const firstThursday = new Date(Date.UTC(tmp.getUTCFullYear(),0,4));
    const diff = (tmp - firstThursday) / 86400000;
    return 1 + Math.floor(diff/7);
  }
  function weekSlug(date=new Date()){
    const year = date.getUTCFullYear();
    const wk = isoWeek(date);
    return `${year}-W${String(wk).padStart(2,'0')}`;
  }
  function parseQuery(){
    const params = new URLSearchParams(location.search);
    return { theme: params.get('theme'), egg: params.get('egg') };
  }
  const Q = parseQuery();

  function selectTheme(){
    const wk = isoWeek(new Date());
    if (Q.theme) {
      const idx = Math.max(1, Math.min(THEMES.length, parseInt(Q.theme,10)));
      return THEMES[idx-1];
    }
    return THEMES[(wk-1) % THEMES.length];
  }

  function resolveAssetPaths(){
    const slug = weekSlug();
    const theme = selectTheme();
    // Use relative paths so this works under any GitHub Pages base URL
    const weeklyBase = `assets/weekly/${slug}`;
    const themeBase  = `assets/themes/${theme.slug}`;
    const files = { player:"player.png", enemy:"enemy.png", coin:"coin.png", tiles:"tiles.png", bg_far:"bg_far.png", bg_mid:"bg_mid.png", bg_near:"bg_near.png" };
    const primary = {}, fallback = {};
    Object.keys(files).forEach(k=>{
      primary[k]  = `${weeklyBase}/${files[k]}`;
      fallback[k] = `${themeBase}/${files[k]}`;
    });
    return { primary, fallback, themeSlug: theme.slug };
  }

  async function loadImageWithFallback(srcPrimary, srcFallback){
    const img = new Image();
    img.decoding = 'async';
    const tryLoad = (src) => new Promise((resolve,reject)=>{
      img.onload = ()=> resolve({img, src});
      img.onerror = ()=> reject(src);
      img.src = src + (src.includes('?')?'&':'?') + 'v=1';
    });
    try { return await tryLoad(srcPrimary); } catch (_) { return await tryLoad(srcFallback); }
  }

  async function loadAssets(){
    const {primary, fallback, themeSlug} = resolveAssetPaths();
    const entries = Object.entries(primary);
    const loaded = await Promise.all(entries.map(async ([k, p])=>{
      const {img} = await loadImageWithFallback(p, fallback[k]);
      return [k, img];
    }));
    const map = Object.fromEntries(loaded);
    map.__themeSlug = themeSlug;
    return map;
  }

  // Always visible here for demo; hide behind triggers in production file if desired.

  function bootstrapGame(){
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    const hudCoins = document.getElementById('hud-coins');
    const hudDist = document.getElementById('hud-dist');
    const hudTheme = document.getElementById('hud-theme');
    const shopEl = document.getElementById('shop');
    const shopGrid = document.getElementById('shop-grid');

    const state = { assets:null, t:0, cameraX:0, scrollSpeed:3, gravity:0.7, jumpV:-12, dashV:12, allowDoubleJump:false, doubleJumped:false, allowDash:false, dashCooldown:0, dashActive:0, magnet:0, shield:0, coins:0, dist:0, paused:false };
    const input = { left:false, right:false, up:false, down:false, jump:false, dash:false };

    window.addEventListener('keydown', e=>{
      const k = e.key;
      if (["ArrowLeft","a","A"].includes(k)) input.left = true;
      if (["ArrowRight","d","D"].includes(k)) input.right = true;
      if (["ArrowUp","w","W"].includes(k)) input.up = true;
      if (["ArrowDown","s","S"].includes(k)) input.down = true;
      if (k === ' ' ) input.jump = true;
      if (k === 'Shift') input.dash = true;
      if (k === 's' || k === 'S'){ state.paused = !state.paused; shopEl.style.display = state.paused ? 'block' : 'none'; if (state.paused) renderShop(); }
    });
    window.addEventListener('keyup', e=>{
      const k = e.key;
      if (["ArrowLeft","a","A"].includes(k)) input.left = false;
      if (["ArrowRight","d","D"].includes(k)) input.right = false;
      if (["ArrowUp","w","W"].includes(k)) input.up = false;
      if (["ArrowDown","s","S"].includes(k)) input.down = false;
      if (k === ' ' ) input.jump = false;
      if (k === 'Shift') input.dash = false;
    });

    const world = { player:{ x:100, y:300, vx:0, vy:0, w:48, h:58, onGround:false, invul:0 }, tiles:[], coins:[], enemies:[], particles:[] };

    function rectsOverlap(a,b){ return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }

    function spawnChunk(baseX){
      const groundY = 460;
      world.tiles.push({x:baseX, y:groundY, w:400, h:H-groundY, type:0});
      for (let i=0;i<4;i++){
        const px = baseX + 60 + i*80 + Math.random()*40;
        const py = 320 + Math.random()*80;
        world.tiles.push({x:px, y:py, w:72, h:16, type:3});
        if (Math.random()<0.3) world.enemies.push({x:px+20,y:py-32,vx:-state.scrollSpeed,vy:0,t:0});
        if (Math.random()<0.5) world.coins.push({x:px+20,y:py-40,vx:-state.scrollSpeed*0.3,vy:0,t:0});
      }
      if (Math.random()<0.25) world.tiles.push({x:baseX+200, y:groundY-24, w:64, h:24, type:4});
    }
    for (let i=0;i<5;i++) spawnChunk(i*380);

    function recycleWorld(){
      const minX = state.cameraX - 200;
      world.tiles = world.tiles.filter(t=> t.x + t.w > minX);
      world.enemies = world.enemies.filter(e=> e.x + 64 > minX);
      world.coins = world.coins.filter(c=> c.x + 32 > minX);
      const maxX = Math.max(...world.tiles.map(t=>t.x+t.w), state.cameraX+W);
      if (maxX < state.cameraX + W + 600) spawnChunk(state.cameraX + W + 200);
    }

    const upgrades = [
      {key:'allowDoubleJump', name:'Double Jump', cost:50, apply: s=>s.allowDoubleJump=true},
      {key:'allowDash', name:'Dash', cost:60, apply: s=>s.allowDash=true},
      {key:'jumpV', name:'Spring Boots (+jump)', cost:40, apply: s=>s.jumpV-=1, max: -16},
      {key:'scrollSpeed', name:'Speed Boots (+speed)', cost:40, apply: s=>s.scrollSpeed+=0.3, max: 6},
      {key:'magnet', name:'Coin Magnet', cost:70, apply: s=>s.magnet=Math.min(180, s.magnet+60), max:180},
      {key:'shield', name:'Shield', cost:80, apply: s=>s.shield=Math.min(300, s.shield+150), max:300},
    ];

    function renderShop(){
      const shopGrid = document.getElementById('shop-grid');
      shopGrid.innerHTML = '';
      upgrades.forEach(up=>{
        const card = document.createElement('div');
        card.className = 'card';
        const curVal = state[up.key] ?? null;
        const owned = (typeof curVal === 'boolean' && curVal === true);
        const capped = (typeof up.max === 'number' && curVal !== null && ((up.key==='jumpV' && curVal<=up.max) || (up.key!=='jumpV' && curVal>=up.max)));
        card.innerHTML = `<div><strong>${up.name}</strong></div>
          <div class="muted">Cost: ${up.cost} ⟡</div>
          <div class="muted">${owned? 'Owned' : (capped? 'Maxed' : '&nbsp;')}</div>`;
        const btn = document.createElement('button');
        btn.textContent = owned? '—' : (capped? 'Maxed' : 'Buy');
        btn.disabled = owned || capped || state.coins < up.cost;
        btn.onclick = ()=>{
          if (state.coins >= up.cost && !owned && !capped){
            state.coins -= up.cost;
            up.apply(state);
            renderShop();
          }
        };
        card.appendChild(btn);
        shopGrid.appendChild(card);
      });
    }

    function spawnDust(x,y,count=6){ for (let i=0;i<count;i++) world.particles.push({x,y, vx:(Math.random()*2-1)*1.5, vy:-Math.random()*2, t: 30+Math.random()*20}); }
    const SPR = { frame(t, len){ return Math.floor(t/8)%len; } };

    function step(){
      if (state.paused) return;
      state.t += 1;
      state.cameraX += state.scrollSpeed;
      state.dist += state.scrollSpeed/10;
      const p = world.player;
      p.vx = 0;
      if (input.left) p.vx -= 3;
      if (input.right) p.vx += 3;
      if (input.jump && (p.onGround || (!state.doubleJumped && state.allowDoubleJump))){
        p.vy = state.jumpV;
        if (!p.onGround) state.doubleJumped = true;
        p.onGround = false;
        spawnDust(p.x+p.w/2, p.y+p.h);
      }
      p.vy += state.gravity;
      if (state.allowDash && input.dash && state.dashCooldown<=0){ state.dashActive = 8; state.dashCooldown = 60; }
      if (state.dashCooldown>0) state.dashCooldown--;
      let dashBoost = 0; if (state.dashActive>0){ dashBoost = state.dashV; state.dashActive--; }
      p.x += p.vx + dashBoost; p.y += p.vy;

      p.onGround = false;
      for (const t of world.tiles){
        const r = {x:t.x - state.cameraX, y:t.y, w:t.w, h:t.h};
        const pr = {x:p.x, y:p.y, w:p.w, h:p.h};
        if (rectsOverlap(pr, r)){
          if (pr.y + pr.h - p.vy <= r.y){ p.y = r.y - p.h; p.vy = 0; p.onGround = true; state.doubleJumped=false; }
          else if (pr.y - p.vy >= r.y + r.h){ p.y = r.y + r.h; p.vy = 0; }
          else if (pr.x + pr.w - (p.vx+dashBoost) <= r.x){ p.x = r.x - p.w; }
          else if (pr.x - (p.vx+dashBoost) >= r.x + r.w){ p.x = r.x + r.w; }
          if (t.type === 4){ p.vy = -8; p.x -= 20; state.cameraX -= 60; state.dist = Math.max(0, state.dist-5); p.invul = 40; state.shield = 0; }
        }
      }
      if (p.invul>0) p.invul--; if (state.shield>0) state.shield--;
      for (const c of world.coins){ c.x -= state.scrollSpeed*0.6; c.t++; }
      if (state.magnet>0){
        for (const c of world.coins){
          const dx = (p.x+24) - (c.x - state.cameraX), dy = (p.y+24) - c.y;
          if (dx*dx+dy*dy < state.magnet*state.magnet){ c.x += dx*0.03; c.y += dy*0.03; }
        }
      }
      for (let i=world.coins.length-1;i>=0;i--){
        const c = world.coins[i]; const r = {x:c.x - state.cameraX, y:c.y, w:24, h:24}; const pr = {x:p.x, y:p.y, w:p.w, h:p.h};
        if (rectsOverlap(pr,r)){ world.coins.splice(i,1); state.coins += 1; spawnDust(p.x+p.w/2, p.y+10, 4); }
      }
      for (const e of world.enemies){ e.x -= state.scrollSpeed; e.t++; }
      for (const e of world.enemies){
        const r = {x:e.x - state.cameraX, y:e.y, w:48, h:48}; const pr = {x:p.x, y:p.y, w:p.w, h:p.h};
        if (rectsOverlap(pr,r)){
          if (p.vy>2){ e.y += 1000; p.vy = -9; state.coins += 2; spawnDust(p.x+20,p.y+20,8); }
          else if (state.shield>0){ e.y += 1000; spawnDust(p.x+20,p.y+20,8); }
          else if (p.invul<=0){ p.invul=40; state.dist = Math.max(0, state.dist-3); }
        }
      }
      for (const prt of world.particles){ prt.x += prt.vx; prt.y += prt.vy; prt.vy += 0.2; prt.t--; }
      world.particles = world.particles.filter(p=>p.t>0);
      recycleWorld();
      if (p.y > H){ p.x = 100; p.y=300; p.vx=0; p.vy=0; state.dist = Math.max(0, state.dist-10); }
      hudCoins.textContent = `⟡ ${state.coins}`; hudDist.textContent = `${Math.floor(state.dist)} m`;
    }

    function draw(){
      const A = state.assets; const cam = state.cameraX; const ctx = document.getElementById('game').getContext('2d'); const H = 576;
      const layers = [ {img:A.bg_far, spd:0.2}, {img:A.bg_mid, spd:0.5}, {img:A.bg_near, spd:0.8} ];
      for (const L of layers){ const w=L.img.width, h=L.img.height, y=(H-h), ox=-((cam*L.spd)%w); ctx.drawImage(L.img, ox, y); ctx.drawImage(L.img, ox+w, y); }
      function drawTileSprite(type, dx,dy,w=64,h=64){ const sx=(type%8)*64, sy=0; ctx.drawImage(A.tiles, sx, sy, 64,64, dx,dy,w,h); }
      for (const t of world.tiles){ const dx=t.x - cam, dy=t.y; if (t.type===0){ for (let x=0;x<t.w;x+=64) drawTileSprite(0,dx+x,dy); } else if (t.type===3){ drawTileSprite(3,dx,dy);} else if (t.type===4){ drawTileSprite(4,dx,dy);} else { drawTileSprite(7,dx,dy);} }
      const cFrame = Math.floor((Math.floor(state.t/8))%4);
      for (const c of world.coins){ const dx=c.x - cam, dy=c.y; ctx.drawImage(A.coin, cFrame*32,0,32,32, dx,dy,24,24); }
      const eFrame = cFrame;
      for (const e of world.enemies){ const dx=e.x - cam, dy=e.y; ctx.drawImage(A.enemy, eFrame*64,0,64,64, dx,dy,48,48); }
      const p = world.player; const animRow = p.onGround?0:1; const runFrame = cFrame; const sx = runFrame*64, sy = animRow*64;
      if (state.shield>0){ ctx.save(); ctx.globalAlpha=0.7; ctx.beginPath(); ctx.arc(p.x+24,p.y+28,36,0,Math.PI*2); ctx.fillStyle='rgba(120,180,255,0.2)'; ctx.fill(); ctx.restore(); }
      if (p.invul>0){ ctx.globalAlpha = (state.t%10<5)? 0.5 : 1; } else { ctx.globalAlpha=1; }
      ctx.drawImage(A.player, sx, sy, 64,64, p.x, p.y, 48,48); ctx.globalAlpha=1;
      ctx.fillStyle='rgba(255,255,255,0.6)'; for (const prt of world.particles){ ctx.fillRect(prt.x, prt.y, 3,3); }
    }

    function loop(){ const ctx = document.getElementById('game').getContext('2d'); ctx.clearRect(0,0,1024,576); step(); draw(); requestAnimationFrame(loop); }

    Promise.resolve(loadAssets()).then(A=>{
      state.assets = A; document.getElementById('hud-theme').textContent = A.__themeSlug; loop();
    });
  }

  loadAssets().then(()=> bootstrapGame());
})();
</script>
</body>
</html>
