---
layout: default
title: Flux Line
permalink: /games/flux-line/
description: Path-tracing reflex game with escalating speed and obstacles.
---

<style>
  .flux-page {
    display: grid;
    gap: 1rem;
  }

  .flux-page > p {
    margin: 0;
    max-width: 64ch;
    color: var(--muted);
  }

  .flux-shell {
    display: grid;
    gap: 0.85rem;
  }

  .flux-hud {
    display: flex;
    flex-wrap: wrap;
    gap: 0.55rem;
  }

  .hud-pill {
    display: inline-flex;
    align-items: center;
    padding: 0.35rem 0.65rem;
    border: 1px solid var(--border);
    border-radius: 999px;
    background: var(--surface);
    color: var(--text);
    font-size: 0.9rem;
  }

  .flux-canvas-wrap {
    border: 1px solid var(--border);
    border-radius: 0.9rem;
    overflow: hidden;
    background: #07111d;
    box-shadow: var(--shadow);
  }

  #flux-canvas {
    display: block;
    width: 100%;
    height: clamp(250px, 48vw, 380px);
    touch-action: none;
    cursor: crosshair;
  }

  .flux-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 0.55rem;
  }

  .flux-button {
    border: 1px solid var(--accent);
    background: var(--accent);
    color: #ffffff;
    border-radius: 0.6rem;
    padding: 0.5rem 0.8rem;
    font: inherit;
    font-weight: 600;
    cursor: pointer;
  }

  .flux-button.ghost {
    background: var(--surface);
    color: var(--text);
    border-color: var(--border);
  }

  .flux-cards {
    display: grid;
    gap: 0.75rem;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  }

  .control-card {
    border: 1px solid var(--border);
    border-radius: 0.8rem;
    background: var(--surface);
    padding: 0.75rem 0.85rem;
  }

  .control-card h4 {
    margin: 0 0 0.35rem;
  }

  .control-card p {
    margin: 0;
    color: var(--muted);
  }
</style>

<section class="flux-page">
  <h1>Flux Line</h1>
  <p><a class="text-link" href="{{ '/games/' | relative_url }}">Back to Games</a></p>
  <p>Keep the flux beam centered in a moving corridor. Move your pointer or touch position to steer the beam. Corridor width shrinks and drift speed rises over time.</p>

  <div class="flux-shell">
    <div class="flux-hud" aria-live="polite">
      <span class="hud-pill" id="flux-score">Score: 0</span>
      <span class="hud-pill" id="flux-best">Best: 0</span>
      <span class="hud-pill" id="flux-level">Level: 1</span>
      <span class="hud-pill" id="flux-state">Status: Ready</span>
    </div>

    <div class="flux-canvas-wrap">
      <canvas id="flux-canvas" aria-label="Flux Line corridor canvas" role="img"></canvas>
    </div>

    <div class="flux-actions">
      <button class="flux-button" id="flux-start" type="button">Start</button>
      <button class="flux-button ghost" id="flux-restart" type="button">Restart</button>
    </div>

    <div class="flux-cards">
      <div class="control-card">
        <h4>Controls</h4>
        <p>Pointer/touch controls horizontal beam position. Keyboard fallback: Arrow Left / Arrow Right.</p>
      </div>
      <div class="control-card">
        <h4>Goal</h4>
        <p>Stay inside the corridor as long as possible. Score rises continuously while stable.</p>
      </div>
      <div class="control-card">
        <h4>Fail State</h4>
        <p>Touching either corridor wall instantly ends the run.</p>
      </div>
    </div>
  </div>
</section>

<script>
(() => {
  // Path model: corridor center is generated by layered sine drift terms,
  // while failure occurs when beamX crosses dynamic corridor boundaries.
  const canvas = document.getElementById('flux-canvas');
  const ctx = canvas.getContext('2d');
  const hudScore = document.getElementById('flux-score');
  const hudBest = document.getElementById('flux-best');
  const hudLevel = document.getElementById('flux-level');
  const hudState = document.getElementById('flux-state');
  const btnStart = document.getElementById('flux-start');
  const btnRestart = document.getElementById('flux-restart');
  const BEST_KEY = 'triwei_flux_line_best';

  const state = {
    running: false,
    gameOver: false,
    score: 0,
    best: 0,
    level: 1,
    trackCenter: 0,
    trackWidth: 190,
    driftPhase: 0,
    driftSpeed: 0.9,
    driftAmp: 60,
    pointerX: null,
    beamX: 0,
    keyboardDir: 0,
    flash: 0,
    particles: [],
    lastTick: 0
  };

  function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
  }

  function rand(min, max) {
    return Math.random() * (max - min) + min;
  }

  function readBest() {
    const parsed = parseInt(localStorage.getItem(BEST_KEY) || '0', 10);
    state.best = Number.isFinite(parsed) ? Math.max(0, parsed) : 0;
  }

  function saveBest() {
    if (state.score > state.best) {
      state.best = state.score;
      localStorage.setItem(BEST_KEY, String(state.best));
    }
  }

  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const { clientWidth, clientHeight } = canvas;
    canvas.width = Math.max(1, Math.floor(clientWidth * dpr));
    canvas.height = Math.max(1, Math.floor(clientHeight * dpr));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    if (!state.running) {
      state.trackCenter = canvas.clientWidth * 0.5;
      state.beamX = state.trackCenter;
    }
    seedParticles();
  }

  function seedParticles() {
    const count = Math.max(40, Math.floor(canvas.clientWidth / 11));
    state.particles = Array.from({ length: count }, () => ({
      x: rand(0, canvas.clientWidth),
      y: rand(0, canvas.clientHeight),
      speed: rand(20, 90),
      size: rand(1, 2.2)
    }));
  }

  function updateHud(text) {
    hudScore.textContent = `Score: ${Math.floor(state.score)}`;
    hudBest.textContent = `Best: ${Math.floor(state.best)}`;
    hudLevel.textContent = `Level: ${state.level}`;
    if (text) {
      hudState.textContent = text;
      return;
    }
    if (state.gameOver) {
      hudState.textContent = 'Status: Breach detected';
      return;
    }
    hudState.textContent = state.running ? 'Status: Stable' : 'Status: Ready';
  }

  function resetState() {
    state.running = true;
    state.gameOver = false;
    state.score = 0;
    state.level = 1;
    state.trackCenter = canvas.clientWidth * 0.5;
    state.trackWidth = Math.min(canvas.clientWidth * 0.55, 190);
    state.driftPhase = 0;
    state.driftSpeed = 0.9;
    state.driftAmp = Math.min(68, canvas.clientWidth * 0.19);
    state.pointerX = null;
    state.keyboardDir = 0;
    state.beamX = state.trackCenter;
    state.flash = 0;
    updateHud('Status: Stable');
  }

  function startGame() {
    resetState();
  }

  function failGame() {
    state.running = false;
    state.gameOver = true;
    saveBest();
    state.flash = 1;
    updateHud('Status: Breach detected - restart');
  }

  function setPointerFromEvent(event) {
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    state.pointerX = clamp(x, 0, canvas.clientWidth);
    if (!state.running) return;
    state.beamX = state.pointerX;
  }

  function updateTrack(dt) {
    state.driftPhase += dt * state.driftSpeed;
    const centerBase = canvas.clientWidth * 0.5;
    const drift = Math.sin(state.driftPhase) * state.driftAmp + Math.sin(state.driftPhase * 0.47) * state.driftAmp * 0.42;
    state.trackCenter = centerBase + drift;
  }

  function updateBeam(dt) {
    const keyboardSpeed = 320;
    if (state.keyboardDir !== 0) {
      state.beamX += state.keyboardDir * keyboardSpeed * dt;
    } else if (state.pointerX !== null) {
      const blend = 0.18;
      state.beamX += (state.pointerX - state.beamX) * blend;
    }
    state.beamX = clamp(state.beamX, 10, canvas.clientWidth - 10);
  }

  function step(dt) {
    for (const p of state.particles) {
      p.y += p.speed * dt;
      if (p.y > canvas.clientHeight + 3) {
        p.y = -3;
        p.x = rand(0, canvas.clientWidth);
      }
    }

    if (!state.running) {
      state.flash = Math.max(0, state.flash - dt * 2.2);
      return;
    }

    state.score += dt * (12 + state.level * 1.4);
    state.level = 1 + Math.floor(state.score / 90);
    state.trackWidth = clamp(190 - state.level * 6.5, 66, 220);
    state.driftSpeed = clamp(0.9 + state.level * 0.065, 0.9, 2.1);
    state.driftAmp = clamp(54 + state.level * 2.2, 54, canvas.clientWidth * 0.34);

    updateTrack(dt);
    updateBeam(dt);

    const left = state.trackCenter - state.trackWidth * 0.5;
    const right = state.trackCenter + state.trackWidth * 0.5;
    if (state.beamX <= left + 4 || state.beamX >= right - 4) {
      failGame();
      return;
    }

    updateHud();
  }

  function drawBackground() {
    const g = ctx.createLinearGradient(0, 0, 0, canvas.clientHeight);
    g.addColorStop(0, '#051120');
    g.addColorStop(1, '#0a2440');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);

    for (const p of state.particles) {
      ctx.fillStyle = `rgba(220, 233, 248, ${0.2 + p.size * 0.18})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawTrack() {
    const left = state.trackCenter - state.trackWidth * 0.5;
    const right = state.trackCenter + state.trackWidth * 0.5;
    const h = canvas.clientHeight;

    ctx.fillStyle = 'rgba(124, 123, 255, 0.18)';
    ctx.fillRect(left, 0, state.trackWidth, h);

    ctx.strokeStyle = 'rgba(124, 123, 255, 0.95)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(left, 0);
    ctx.lineTo(left, h);
    ctx.moveTo(right, 0);
    ctx.lineTo(right, h);
    ctx.stroke();
  }

  function drawBeam() {
    const y = canvas.clientHeight * 0.8;
    const glow = ctx.createRadialGradient(state.beamX, y, 1, state.beamX, y, 24);
    glow.addColorStop(0, 'rgba(52, 245, 197, 0.95)');
    glow.addColorStop(1, 'rgba(52, 245, 197, 0.08)');
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(state.beamX, y, 24, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = '#34f5c5';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(state.beamX, y + 22);
    ctx.lineTo(state.beamX, y - 90);
    ctx.stroke();

    ctx.fillStyle = '#34f5c5';
    ctx.beginPath();
    ctx.arc(state.beamX, y, 8, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawOverlay() {
    if (state.running) return;
    ctx.fillStyle = `rgba(3, 7, 12, ${0.5 + state.flash * 0.2})`;
    ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);

    ctx.fillStyle = '#e8eef5';
    ctx.textAlign = 'center';
    ctx.font = '600 22px "IBM Plex Sans", sans-serif';
    const title = state.gameOver ? 'Flux Breach' : 'Flux Line';
    ctx.fillText(title, canvas.clientWidth / 2, canvas.clientHeight / 2 - 18);
    ctx.font = '400 14px "IBM Plex Sans", sans-serif';
    const msg = state.gameOver
      ? 'Press Restart or Space to retry'
      : 'Move pointer in canvas, then press Start';
    ctx.fillText(msg, canvas.clientWidth / 2, canvas.clientHeight / 2 + 10);
  }

  function render() {
    drawBackground();
    drawTrack();
    drawBeam();
    drawOverlay();
  }

  function loop(timestamp) {
    if (!state.lastTick) state.lastTick = timestamp;
    const dt = Math.min(0.04, (timestamp - state.lastTick) / 1000);
    state.lastTick = timestamp;
    step(dt);
    render();
    requestAnimationFrame(loop);
  }

  btnStart.addEventListener('click', startGame);
  btnRestart.addEventListener('click', startGame);
  canvas.addEventListener('pointerdown', (event) => {
    event.preventDefault();
    setPointerFromEvent(event);
    if (!state.running) startGame();
  });
  canvas.addEventListener('pointermove', (event) => {
    setPointerFromEvent(event);
  });
  canvas.addEventListener('pointerleave', () => {
    state.pointerX = null;
  });

  window.addEventListener('keydown', (event) => {
    if (event.code === 'ArrowLeft') state.keyboardDir = -1;
    if (event.code === 'ArrowRight') state.keyboardDir = 1;
    if (event.code === 'Space') {
      event.preventDefault();
      if (!state.running) startGame();
    }
  });
  window.addEventListener('keyup', (event) => {
    if (event.code === 'ArrowLeft' && state.keyboardDir === -1) state.keyboardDir = 0;
    if (event.code === 'ArrowRight' && state.keyboardDir === 1) state.keyboardDir = 0;
  });
  window.addEventListener('resize', resizeCanvas);

  readBest();
  resizeCanvas();
  updateHud('Status: Ready');
  requestAnimationFrame(loop);
})();
</script>
