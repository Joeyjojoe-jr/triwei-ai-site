---
layout: default
title: Orbit Runner
permalink: /games/orbit-runner/
---

<section class="game-page">
  <h1>Orbit Runner</h1>
  <p><a class="text-link" href="{{ '/games/' | relative_url }}">Back to Games</a></p>
  <p>Slingshot around gravity wells. Press Start, then hold Space or hold on the canvas to fire thrusters away from the nearest well. Survive and build distance.</p>
  <div class="game-shell">
    <div class="game-hud" aria-live="polite">
      <span class="hud-pill" id="orbit-distance">Distance: 0</span>
      <span class="hud-pill" id="orbit-slings">Slings: 0</span>
      <span class="hud-pill" id="orbit-best">Best: 0</span>
      <span class="hud-pill" id="orbit-state">Status: Ready</span>
    </div>
    <div class="game-canvas-wrap">
      <canvas id="orbit-canvas" aria-label="Orbit Runner game canvas" role="img"></canvas>
    </div>
    <div class="game-actions">
      <button class="game-button" id="orbit-start" type="button">Start Run</button>
      <button class="game-button ghost" id="orbit-restart" type="button">Restart</button>
    </div>
    <div class="game-controls">
      <div class="control-card">
        <h4>Controls</h4>
        <p>Press Start Run, then hold Space, mouse, or touch to fire thrusters away from the nearest gravity well.</p>
      </div>
      <div class="control-card">
        <h4>Goal</h4>
        <p>Stay in orbit, avoid crashing, and chain slings for bonus distance.</p>
      </div>
      <div class="control-card">
        <h4>Tip</h4>
        <p>Short bursts keep you stable. Long holds are risky when speed ramps up.</p>
      </div>
    </div>
  </div>
</section>

<script>
(() => {
  // Math model: each well applies inverse-square gravity (F ~ 1/r^2),
  // velocity integrates that acceleration per frame, and thrust applies a
  // normalized vector away from the nearest well.
  const canvas = document.getElementById('orbit-canvas');
  const ctx = canvas.getContext('2d');
  const hudDistance = document.getElementById('orbit-distance');
  const hudSlings = document.getElementById('orbit-slings');
  const hudBest = document.getElementById('orbit-best');
  const hudState = document.getElementById('orbit-state');
  const btnStart = document.getElementById('orbit-start');
  const btnRestart = document.getElementById('orbit-restart');

  const state = {
    running: false,
    gameOver: false,
    distance: 0,
    slings: 0,
    speed: 0,
    time: 0,
    best: 0,
  };

  const config = {
    baseSpeed: 165,
    speedRamp: 3.4,
    gravity: 68000,
    thrust: 440,
    dragPerFrame: 0.992,
    shipRadius: 8,
    wellMinRadius: 28,
    wellMaxRadius: 52,
    wellSpacing: [420, 640],
    slingshotRing: 88,
    slingshotBonus: 26,
  };

  const ship = { x: 180, y: 240, vx: 0, vy: 0 };
  let wells = [];
  let stars = [];
  let inputActive = false;
  let lastTime = 0;
  let nextWellX = 0;

  function rand(min, max) {
    return Math.random() * (max - min) + min;
  }

  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const { clientWidth, clientHeight } = canvas;
    canvas.width = Math.max(1, Math.floor(clientWidth * dpr));
    canvas.height = Math.max(1, Math.floor(clientHeight * dpr));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    if (!state.running) {
      ship.x = Math.max(160, canvas.clientWidth * 0.22);
      ship.y = canvas.clientHeight * 0.5;
    }
    buildStars();
  }

  function buildStars() {
    const count = Math.floor(canvas.clientWidth / 6);
    stars = Array.from({ length: count }, () => ({
      x: Math.random() * canvas.clientWidth,
      y: Math.random() * canvas.clientHeight,
      r: rand(0.6, 1.8),
      speed: rand(0.2, 0.6),
    }));
  }

  function spawnWell(x) {
    const r = rand(config.wellMinRadius, config.wellMaxRadius);
    const y = rand(r + 40, canvas.clientHeight - r - 40);
    const strength = rand(0.88, 1.36);
    wells.push({
      x,
      y,
      r,
      strength,
      scored: false,
    });
  }

  function setupWells() {
    wells = [];
    nextWellX = canvas.clientWidth + 260;
    while (nextWellX < canvas.clientWidth + 1200) {
      spawnWell(nextWellX);
      nextWellX += rand(...config.wellSpacing);
    }
  }

  function startGame() {
    state.running = true;
    state.gameOver = false;
    state.distance = 0;
    state.slings = 0;
    state.speed = config.baseSpeed;
    state.time = 0;
    ship.vx = 0;
    ship.vy = 0;
    ship.x = Math.max(160, canvas.clientWidth * 0.22);
    ship.y = canvas.clientHeight * 0.5;
    setupWells();
    hudState.textContent = 'Status: Active';
  }

  function endGame() {
    state.running = false;
    state.gameOver = true;
    hudState.textContent = 'Status: Crashed - press Restart';
    state.best = Math.max(state.best, Math.floor(state.distance));
    localStorage.setItem('triwei_orbit_best', String(state.best));
  }

  function updateHud() {
    hudDistance.textContent = `Distance: ${Math.floor(state.distance)}`;
    hudSlings.textContent = `Slings: ${state.slings}`;
    hudBest.textContent = `Best: ${state.best}`;
  }

  function nearestWell() {
    let best = null;
    let bestDist = Infinity;
    for (const well of wells) {
      const dx = well.x - ship.x;
      const dy = well.y - ship.y;
      const dist = Math.hypot(dx, dy);
      if (dist < bestDist) {
        bestDist = dist;
        best = well;
      }
    }
    return best;
  }

  function step(dt) {
    if (!state.running) return;
    state.time += dt;
    state.speed = config.baseSpeed + state.time * config.speedRamp;
    state.distance += state.speed * dt * 0.1;

    for (const star of stars) {
      star.x -= state.speed * star.speed * dt;
      if (star.x < -5) {
        star.x = canvas.clientWidth + rand(10, 120);
        star.y = rand(0, canvas.clientHeight);
      }
    }

    for (const well of wells) {
      well.x -= state.speed * dt;
    }
    nextWellX -= state.speed * dt;
    wells = wells.filter(well => well.x + well.r > -120);

    while (nextWellX < canvas.clientWidth + 1200) {
      spawnWell(nextWellX);
      nextWellX += rand(...config.wellSpacing);
    }

    const targetX = canvas.clientWidth * 0.22;
    ship.vx += (targetX - ship.x) * dt * 0.9;
    const drag = Math.pow(config.dragPerFrame, dt * 60);
    ship.vx *= drag;
    ship.vy *= drag;

    for (const well of wells) {
      const dx = well.x - ship.x;
      const dy = well.y - ship.y;
      const distSq = dx * dx + dy * dy + 160;
      const dist = Math.sqrt(distSq);
      const pull = (config.gravity * well.strength) / distSq;
      ship.vx += (dx / dist) * pull * dt;
      ship.vy += (dy / dist) * pull * dt;

      if (!well.scored && dist < well.r + config.slingshotRing && dist > well.r + config.shipRadius + 6) {
        state.slings += 1;
        state.distance += config.slingshotBonus;
        well.scored = true;
      }

      if (dist < well.r + config.shipRadius) {
        endGame();
      }
    }

    if (inputActive) {
      const focus = nearestWell();
      if (focus) {
        const dx = ship.x - focus.x;
        const dy = ship.y - focus.y;
        const dist = Math.hypot(dx, dy) || 1;
        ship.vx += (dx / dist) * config.thrust * dt;
        ship.vy += (dy / dist) * config.thrust * dt;
      }
    }

    ship.x += ship.vx * dt;
    ship.y += ship.vy * dt;

    if (ship.y < -40 || ship.y > canvas.clientHeight + 40) {
      endGame();
    }

    updateHud();
  }

  function drawWell(well) {
    const glow = ctx.createRadialGradient(well.x, well.y, well.r * 0.2, well.x, well.y, well.r * 1.3);
    glow.addColorStop(0, 'rgba(124, 123, 255, 0.7)');
    glow.addColorStop(0.6, 'rgba(124, 123, 255, 0.2)');
    glow.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(well.x, well.y, well.r * 1.3, 0, Math.PI * 2);
    ctx.fill();

    const core = ctx.createRadialGradient(well.x, well.y, 0, well.x, well.y, well.r);
    core.addColorStop(0, '#f6f2ff');
    core.addColorStop(0.5, '#7c7bff');
    core.addColorStop(1, '#1b1f44');
    ctx.fillStyle = core;
    ctx.beginPath();
    ctx.arc(well.x, well.y, well.r, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawShip() {
    const angle = Math.atan2(ship.vy, 1.5);
    ctx.save();
    ctx.translate(ship.x, ship.y);
    ctx.rotate(angle);
    ctx.beginPath();
    ctx.moveTo(12, 0);
    ctx.lineTo(-10, -6);
    ctx.lineTo(-6, 0);
    ctx.lineTo(-10, 6);
    ctx.closePath();
    ctx.fillStyle = '#ff8a5c';
    ctx.fill();
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.stroke();

    if (inputActive && state.running && !state.gameOver) {
      ctx.beginPath();
      ctx.moveTo(-10, 0);
      ctx.lineTo(-18, rand(-4, 4));
      ctx.lineTo(-8, rand(-2, 2));
      ctx.closePath();
      ctx.fillStyle = 'rgba(52, 245, 197, 0.8)';
      ctx.fill();
    }
    ctx.restore();
  }

  function drawStars() {
    for (const star of stars) {
      ctx.fillStyle = `rgba(255, 255, 255, ${0.4 + star.r * 0.2})`;
      ctx.beginPath();
      ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawOverlay() {
    if (state.running) return;
    ctx.save();
    ctx.fillStyle = 'rgba(4, 6, 14, 0.65)';
    ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);

    ctx.fillStyle = '#e8eef5';
    ctx.textAlign = 'center';
    ctx.font = '600 20px \"IBM Plex Sans\", sans-serif';
    const message = state.gameOver ? 'Crash detected' : 'Orbit Runner';
    ctx.fillText(message, canvas.clientWidth / 2, canvas.clientHeight / 2 - 20);
    ctx.font = '400 14px \"IBM Plex Sans\", sans-serif';
    const sub = state.gameOver
      ? 'Press Space or tap to restart'
      : 'Hold Space or touch to fire thrusters';
    ctx.fillText(sub, canvas.clientWidth / 2, canvas.clientHeight / 2 + 10);
    ctx.restore();
  }

  function render() {
    ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
    drawStars();
    for (const well of wells) drawWell(well);
    drawShip();
    drawOverlay();
  }

  function loop(timestamp) {
    if (!lastTime) {
      lastTime = timestamp;
    }
    const dt = Math.min(0.05, (timestamp - lastTime) / 1000);
    lastTime = timestamp;
    step(dt);
    render();
    requestAnimationFrame(loop);
  }

  function handleStart() {
    if (!state.running) {
      startGame();
    }
  }

  window.addEventListener('keydown', (event) => {
    if (event.code === 'Space') {
      event.preventDefault();
      inputActive = true;
      handleStart();
    }
    if (event.code === 'KeyR' && state.gameOver) {
      event.preventDefault();
      startGame();
    }
  });

  window.addEventListener('keyup', (event) => {
    if (event.code === 'Space') {
      event.preventDefault();
      inputActive = false;
    }
  });

  canvas.addEventListener('pointerdown', (event) => {
    event.preventDefault();
    inputActive = true;
    handleStart();
  });

  window.addEventListener('pointerup', () => {
    inputActive = false;
  });
  window.addEventListener('pointercancel', () => {
    inputActive = false;
  });
  btnStart.addEventListener('click', () => {
    startGame();
  });
  btnRestart.addEventListener('click', () => {
    startGame();
  });

  window.addEventListener('resize', resizeCanvas);

  const parsedBest = parseInt(localStorage.getItem('triwei_orbit_best') || '0', 10);
  state.best = Number.isFinite(parsedBest) ? Math.max(0, parsedBest) : 0;
  hudState.textContent = 'Status: Ready';
  resizeCanvas();
  setupWells();
  updateHud();
  requestAnimationFrame(loop);
})();
</script>
