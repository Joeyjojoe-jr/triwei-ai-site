---
layout: default
title: Signal Drift
permalink: /games/signal-drift/
description: Single-button timing challenge with escalating tempo.
---

<style>
  .signal-page {
    display: grid;
    gap: 1rem;
  }

  .signal-page > p {
    margin: 0;
    max-width: 62ch;
    color: var(--muted);
  }

  .signal-shell {
    display: grid;
    gap: 0.85rem;
  }

  .signal-hud {
    display: flex;
    flex-wrap: wrap;
    gap: 0.55rem;
  }

  .hud-pill {
    display: inline-flex;
    align-items: center;
    padding: 0.35rem 0.65rem;
    border: 1px solid var(--border);
    border-radius: 999px;
    background: var(--surface);
    color: var(--text);
    font-size: 0.9rem;
  }

  .signal-canvas-wrap {
    border: 1px solid var(--border);
    border-radius: 0.9rem;
    overflow: hidden;
    background: #09111b;
    box-shadow: var(--shadow);
  }

  #signal-canvas {
    display: block;
    width: 100%;
    height: clamp(340px, 56vh, 620px);
    touch-action: manipulation;
  }

  .signal-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 0.55rem;
  }

  .signal-button {
    border: 1px solid var(--accent);
    background: var(--accent);
    color: #ffffff;
    border-radius: 0.6rem;
    padding: 0.5rem 0.8rem;
    font: inherit;
    font-weight: 600;
    cursor: pointer;
  }

  .signal-button.ghost {
    background: var(--surface);
    color: var(--text);
    border-color: var(--border);
  }

  .signal-controls {
    display: grid;
    gap: 0.75rem;
    grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
  }

  .control-card {
    border: 1px solid var(--border);
    border-radius: 0.8rem;
    background: var(--surface);
    padding: 0.75rem 0.85rem;
  }

  .control-card h4 {
    margin: 0 0 0.35rem;
  }

  .control-card p {
    margin: 0;
    color: var(--muted);
  }
</style>

<section class="signal-page">
  <h1>Signal Drift</h1>
  <p><a class="text-link" href="{{ '/games/' | relative_url }}">Back to Games</a></p>
  <p>Single-button timing challenge. Press Space, Enter, click, or tap exactly when the marker is inside the target zone. Every hit makes the tempo faster and the safe zone smaller.</p>
  <div class="signal-shell">
    <div class="signal-hud" aria-live="polite">
      <span class="hud-pill" id="signal-score">Score: 0</span>
      <span class="hud-pill" id="signal-best">Best: 0</span>
      <span class="hud-pill" id="signal-tempo">Tempo: 200</span>
      <span class="hud-pill" id="signal-lives">Lives: 3</span>
      <span class="hud-pill" id="signal-error">Error: --</span>
      <span class="hud-pill" id="signal-state">Status: Ready</span>
    </div>
    <div class="signal-canvas-wrap">
      <canvas id="signal-canvas" aria-label="Signal Drift timing lane" role="img"></canvas>
    </div>
    <div class="signal-actions">
      <button class="signal-button" id="signal-restart" type="button">Restart Run</button>
      <button class="signal-button ghost" id="signal-start" type="button">Start</button>
    </div>
    <div class="signal-controls">
      <div class="control-card">
        <h4>Controls</h4>
        <p>Use one input only: Space, Enter, click, or tap.</p>
      </div>
      <div class="control-card">
        <h4>Goal</h4>
        <p>Land as many perfect timing hits as possible in a single run.</p>
      </div>
      <div class="control-card">
        <h4>Fail State</h4>
        <p>Each miss costs one life. The run ends after 3 misses.</p>
      </div>
    </div>
  </div>
</section>

<script>
(() => {
  // Timing model: success is |markerX - targetX| <= targetWidth/2; tempo
  // and difficulty increase by scaling speed up and shrinking target width.
  const canvas = document.getElementById('signal-canvas');
  const ctx = canvas.getContext('2d');
  const hudScore = document.getElementById('signal-score');
  const hudBest = document.getElementById('signal-best');
  const hudTempo = document.getElementById('signal-tempo');
  const hudLives = document.getElementById('signal-lives');
  const hudError = document.getElementById('signal-error');
  const hudState = document.getElementById('signal-state');
  const btnRestart = document.getElementById('signal-restart');
  const btnStart = document.getElementById('signal-start');
  const BEST_KEY = 'triwei_signal_drift_best';

  const state = {
    running: false,
    gameOver: false,
    score: 0,
    best: 0,
    speed: 200,
    level: 1,
    lives: 3,
    lastError: null,
    markerX: 80,
    markerDir: 1,
    targetX: 260,
    targetWidth: 150,
    flash: 0,
    lastTick: 0
  };

  function rand(min, max) {
    return Math.random() * (max - min) + min;
  }

  function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }

  function readBest() {
    const parsed = parseInt(localStorage.getItem(BEST_KEY) || '0', 10);
    state.best = Number.isFinite(parsed) ? Math.max(0, parsed) : 0;
  }

  function saveBest() {
    if (state.score > state.best) {
      state.best = state.score;
      localStorage.setItem(BEST_KEY, String(state.best));
    }
  }

  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const { clientWidth, clientHeight } = canvas;
    canvas.width = Math.max(1, Math.floor(clientWidth * dpr));
    canvas.height = Math.max(1, Math.floor(clientHeight * dpr));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    if (!state.running) {
      state.markerX = canvas.clientWidth * 0.2;
      if (state.targetX > canvas.clientWidth - 32) {
        state.targetX = canvas.clientWidth * 0.65;
      }
    }
  }

  function randomizeTarget() {
    const margin = 56;
    const half = state.targetWidth / 2;
    const min = margin + half;
    const max = canvas.clientWidth - margin - half;
    if (max <= min) {
      state.targetX = canvas.clientWidth * 0.5;
      return;
    }
    state.targetX = rand(min, max);
  }

  function updateHud(statusText) {
    hudScore.textContent = `Score: ${state.score}`;
    hudBest.textContent = `Best: ${state.best}`;
    hudTempo.textContent = `Tempo: ${Math.round(state.speed)}`;
    hudLives.textContent = `Lives: ${state.lives}`;
    hudError.textContent = state.lastError === null ? 'Error: --' : `Error: ${Math.round(state.lastError)}px`;
    if (statusText) {
      hudState.textContent = statusText;
      return;
    }
    if (!state.running && !state.gameOver) {
      hudState.textContent = 'Status: Ready';
      return;
    }
    if (state.gameOver) {
      hudState.textContent = 'Status: Missed - restart';
      return;
    }
    hudState.textContent = 'Status: Active';
  }

  function startRun() {
    state.running = true;
    state.gameOver = false;
    state.score = 0;
    state.level = 1;
    state.speed = 200;
    state.lives = 3;
    state.lastError = null;
    state.targetWidth = 150;
    state.markerDir = 1;
    state.markerX = canvas.clientWidth * 0.2;
    state.flash = 0;
    randomizeTarget();
    updateHud('Status: Active');
  }

  function failRun() {
    state.running = false;
    state.gameOver = true;
    saveBest();
    updateHud('Status: Missed - press Start or Space');
  }

  function registerHit() {
    state.score += 1;
    state.level += 1;
    state.speed = Math.min(560, state.speed * 1.06 + 6);
    state.targetWidth = Math.max(52, state.targetWidth * 0.95);
    state.lastError = 0;
    state.flash = 1;
    randomizeTarget();
    updateHud('Status: Hit');
  }

  function handleAction() {
    if (!state.running) {
      startRun();
      return;
    }

    const delta = Math.abs(state.markerX - state.targetX);
    state.lastError = delta;
    if (delta <= state.targetWidth / 2) {
      registerHit();
      return;
    }
    state.lives -= 1;
    state.flash = 0.75;
    if (state.lives <= 0) {
      failRun();
      return;
    }
    randomizeTarget();
    updateHud('Status: Missed - keep going');
  }

  function step(dt) {
    if (!state.running) return;

    state.markerX += state.markerDir * state.speed * dt;
    const minX = 18;
    const maxX = canvas.clientWidth - 18;
    if (state.markerX <= minX) {
      state.markerX = minX;
      state.markerDir = 1;
    } else if (state.markerX >= maxX) {
      state.markerX = maxX;
      state.markerDir = -1;
    }

    state.flash = Math.max(0, state.flash - dt * 2.6);
    updateHud();
  }

  function drawLane() {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const laneY = h * 0.55;

    const bg = ctx.createLinearGradient(0, 0, 0, h);
    bg.addColorStop(0, '#081321');
    bg.addColorStop(1, '#0b1b2d');
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, w, h);

    ctx.strokeStyle = 'rgba(140, 176, 210, 0.32)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(18, laneY);
    ctx.lineTo(w - 18, laneY);
    ctx.stroke();

    const pulse = 0.28 + state.flash * 0.45;
    ctx.fillStyle = `rgba(52, 245, 197, ${pulse})`;
    ctx.fillRect(state.targetX - state.targetWidth / 2, laneY - 22, state.targetWidth, 44);
    ctx.strokeStyle = 'rgba(52, 245, 197, 0.95)';
    ctx.lineWidth = 2;
    ctx.strokeRect(state.targetX - state.targetWidth / 2, laneY - 22, state.targetWidth, 44);

    const glow = ctx.createRadialGradient(state.markerX, laneY, 1, state.markerX, laneY, 18);
    glow.addColorStop(0, 'rgba(255, 138, 92, 1)');
    glow.addColorStop(1, 'rgba(255, 138, 92, 0.08)');
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(state.markerX, laneY, 18, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#ff8a5c';
    ctx.beginPath();
    ctx.arc(state.markerX, laneY, 7.5, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawOverlay() {
    if (state.running) return;

    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    ctx.fillStyle = 'rgba(3, 7, 12, 0.55)';
    ctx.fillRect(0, 0, w, h);

    ctx.fillStyle = '#e8eef5';
    ctx.textAlign = 'center';
    ctx.font = '600 22px "IBM Plex Sans", sans-serif';
    const title = state.gameOver ? 'Signal Lost' : 'Signal Drift';
    ctx.fillText(title, w / 2, h / 2 - 18);
    ctx.font = '400 14px "IBM Plex Sans", sans-serif';
    const msg = state.gameOver
      ? 'Press Start, Space, Enter, click, or tap to retry'
      : 'Press Start or use one input to begin';
    ctx.fillText(msg, w / 2, h / 2 + 10);
  }

  function render() {
    drawLane();
    drawOverlay();
  }

  function loop(timestamp) {
    if (!state.lastTick) state.lastTick = timestamp;
    const dt = Math.min(0.05, (timestamp - state.lastTick) / 1000);
    state.lastTick = timestamp;
    step(dt);
    render();
    requestAnimationFrame(loop);
  }

  btnStart.addEventListener('click', handleAction);
  btnRestart.addEventListener('click', startRun);
  canvas.addEventListener('pointerdown', (event) => {
    event.preventDefault();
    handleAction();
  });

  window.addEventListener('keydown', (event) => {
    if (event.code !== 'Space' && event.code !== 'Enter' && event.code !== 'NumpadEnter') {
      return;
    }
    event.preventDefault();
    handleAction();
  });

  window.addEventListener('resize', resizeCanvas);

  readBest();
  resizeCanvas();
  randomizeTarget();
  updateHud();
  requestAnimationFrame(loop);
})();
</script>
